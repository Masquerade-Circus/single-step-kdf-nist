{"version":3,"file":"single-step-kdf.js","sourceRoot":"/","sources":["single-step-kdf.ts"],"names":[],"mappings":";;;;;AAAA,oDAA4B;AAE5B,mCAAqC;AAErC,MAAM,wBAAyB,SAAQ,KAAK;IAC1C,YAAmB,GAAW;QAC5B,KAAK,CAAC,GAAG,CAAC,CAAC;IACb,CAAC;CACF;AAED;;;;;;;;;GASG;AACH,MAAM,aAAa,GAAG,CAAC,IAAY,EAAU,EAAE;IAC7C,QAAQ,IAAI,EAAE;QACZ,KAAK,QAAQ;YACX,OAAO,EAAE,CAAC;QACZ,KAAK,QAAQ;YACX,OAAO,EAAE,CAAC;QACZ,KAAK,QAAQ;YACX,OAAO,EAAE,CAAC;QACZ,KAAK,QAAQ;YACX,OAAO,EAAE,CAAC;QACZ,KAAK,UAAU;YACb,OAAO,EAAE,CAAC;QACZ,KAAK,UAAU;YACb,OAAO,EAAE,CAAC;QACZ,KAAK,UAAU;YACb,OAAO,EAAE,CAAC;QACZ,KAAK,UAAU;YACb,OAAO,EAAE,CAAC;QACZ,KAAK,YAAY;YACf,OAAO,EAAE,CAAC;QACZ,KAAK,YAAY;YACf,OAAO,EAAE,CAAC;QACZ,KAAK,MAAM;YACT,OAAO,EAAE,CAAC;QACZ,KAAK,KAAK;YACR,OAAO,EAAE,CAAC;QACZ,OAAO,CAAC,CAAC;YACP,OAAO,gBAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,MAAM,CAAC;SAChD;KACF;AACH,CAAC,CAAC;AAEF,MAAM,WAAW,GAAG,CAAC,OAAe,EAAc,EAAE;IAClD,OAAO,kBAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;AACzD,CAAC,CAAC;AAEF,MAAM,cAAc,GAAG,CAAC,cAAsB,EAAQ,EAAE;IACtD,IAAI,cAAc,IAAI,CAAC,EAAE;QACvB,MAAM,IAAI,wBAAwB,CAChC,wCAAwC,CACzC,CAAC;KACH;AACH,CAAC,CAAC;AAEF;;;;;;;;;;;;;;;;;GAiBG;AACU,QAAA,aAAa,GAAG,CAC3B,IAAU,EACV,aAAyB,EACzB,cAAsB,EACtB,SAAqB,EACT,EAAE;IACd,cAAc,CAAC,cAAc,CAAC,CAAC;IAE/B,MAAM,gBAAgB,GAAG,aAAa,CAAC,QAAQ,CAAC,CAAC;IAEjD,MAAM,MAAM,GAAG,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,CAAC;IAE5C,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,cAAc,GAAG,gBAAgB,CAAC,CAAC;IAC1D;;;;;;;;;;;;;;;;;;;;;;;;;SAyBK;IACL,IAAI,OAAO,GAAG,CAAC,CAAC;IAChB,IAAI,YAAY,GAAG,CAAC,CAAC;IAErB,GAAG;QACD,gBAAM;aACH,UAAU,CAAC,IAAI,CAAC;aAChB,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;aAC5B,MAAM,CAAC,aAAa,CAAC;aACrB,MAAM,CAAC,SAAS,CAAC;aACjB,MAAM,EAAE;aACR,IAAI,CACH,MAAM,EACN,CAAC,EACD,CAAC,EACD,IAAI,KAAK,OAAO,CAAC,CAAC,CAAC,cAAc,GAAG,YAAY,CAAC,CAAC,CAAC,gBAAgB,CACpE,CAAC;QAEJ,YAAY,IAAI,gBAAgB,CAAC;KAClC,QAAQ,OAAO,EAAE,GAAG,IAAI,EAAE;IAC3B,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,CAAC;AAC9C,CAAC,CAAC","sourcesContent":["import crypto from \"crypto\";\nimport { Hash } from \"./types\";\nimport { hexToBytes } from \"./utils\";\n\nclass IllegalArgumentException extends Error {\n  public constructor(msg: string) {\n    super(msg);\n  }\n}\n\n/**\n * Get expected hash length.\n *\n * @func\n * @alias hkdf.getHashLength\n * @param {string} hash - Hash algorithm\n * @returns {number} hash digest byte length\n *\n * @note Values are hardcoded with fallback for unknown algorithms.\n */\nconst getHashLength = (hash: string): number => {\n  switch (hash) {\n    case \"sha256\":\n      return 32;\n    case \"sha512\":\n      return 64;\n    case \"sha224\":\n      return 28;\n    case \"sha384\":\n      return 48;\n    case \"sha3-256\":\n      return 32;\n    case \"sha3-512\":\n      return 64;\n    case \"sha3-224\":\n      return 28;\n    case \"sha3-384\":\n      return 48;\n    case \"blake2s256\":\n      return 32;\n    case \"blake2b512\":\n      return 64;\n    case \"sha1\":\n      return 20;\n    case \"md5\":\n      return 16;\n    default: {\n      return crypto.createHash(hash).digest().length;\n    }\n  }\n};\n\nconst intTo4Bytes = (counter: number): Uint8Array => {\n  return hexToBytes(counter.toString().padStart(7, \"0\"));\n};\n\nconst checkOutLength = (outLengthBytes: number): void => {\n  if (outLengthBytes <= 0) {\n    throw new IllegalArgumentException(\n      \"outLengthBytes must be greatear than 0\"\n    );\n  }\n};\n\n/**\n * KDM - a one step key derivation function as described in NIST SP 800-56C REV 1 Chapter 4.1.\n *\n * Derives a key with the given parameters. At the moment, just derivation using SHA-256 is available.\n *\n * @param hash           The hash to use.\n * @param sharedSecretZ  Known as `Z` in the spec: a byte string that represents the shared secret\n * @param outLengthBytes Knnown as `L` in the spec: positive integer that indicates the lenght (in bytes) of the secret\n *                       keying material to be derived; how long the output will be.\n * @param fixedInfo      A bit string of context-specific data that is appropiate for the relying key-establishment scheme.\n *                       FixedInfo may, for example, include appropriately formatted representations of the values of salt and/or L.\n *                       The inclusion of additional copies of the values of salt and L in FixedInfo would ensure that\n *                       each block of derived keying material is affected by all of the information\n *                       conveyed in OtherInput. See [SP 800-56A] and [SP 800-56B] for more detailed\n *                       recommendations concerning the format and content of FixedInfo.\n * @returns The derived keying material.\n * @throws IllegalArgumentException if `outLengthBytes` is 0 bytes.\n */\nexport const singleStepKDF = (\n  hash: Hash,\n  sharedSecretZ: Uint8Array,\n  outLengthBytes: number,\n  fixedInfo: Uint8Array\n): Uint8Array => {\n  checkOutLength(outLengthBytes);\n\n  const digestByteLength = getHashLength(\"sha256\");\n\n  const buffer = Buffer.alloc(outLengthBytes);\n\n  const reps = Math.ceil(outLengthBytes / digestByteLength);\n  /*\n     1. If L > 0, then set reps = [L / H_outputBits]\n        otherwise, output an error indicator and exit\n        this process without performing the remaining\n        actions (i.e., omitting steps 2 through 8).\n     2. If reps > (2^32 −1), then output an error indicator\n        and exit this process without performing the remaining\n        actions (i.e., omitting steps 3 through 8).\n     3. Initialize a big-endian 4-byte unsigned integer\n        counter as 0x00000000, corresponding to a 32-bit\n        binary representation of the number zero.\n     4. If counter || Z || FixedInfo is more tha\n        max_H_inputBits bits long, then output an\n        error indicator and exit this process without\n        performing any of the remaining actions (i.e.,\n        omitting steps 5 through 8).\n     5. Initialize Result(0) as an empty bit string\n        (i.e., the null string).\n     6. For i = 1 to reps, do the following:\n        6.1 Increment counter by 1.\n        6.2 Compute K(i) = H(counter || Z || FixedInfo).\n        6.3 Set Result(i) = Result(i – 1) ||K(i).\n     7. Set DerivedKeyingMaterial equal to the leftmost L\n        bits of Result(reps).\n     8. Output DerivedKeyingMaterial.\n     */\n  let counter = 1;\n  let outputLenSum = 0;\n\n  do {\n    crypto\n      .createHash(hash)\n      .update(intTo4Bytes(counter))\n      .update(sharedSecretZ)\n      .update(fixedInfo)\n      .digest()\n      .copy(\n        buffer,\n        0,\n        0,\n        reps === counter ? outLengthBytes - outputLenSum : digestByteLength\n      );\n\n    outputLenSum += digestByteLength;\n  } while (counter++ < reps);\n  return new Uint8Array(buffer.toJSON().data);\n};\n"]}